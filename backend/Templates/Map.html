{% extends "base.html" %}
{% block title %}Peak Times{% endblock %}

{% block content %}
{% if messages %}
<div class="messages" style="position: fixed; top: 20px; right: 20px; z-index: 1000;">
    {% for message in messages %}
    <div class="alert {% if message.tags == 'error' %}alert-danger{% else %}alert-success{% endif %}" 
        style="padding: 15px; margin-bottom: 10px; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
        {{ message }}
    </div>
    {% endfor %}
</div>
{% endif %}

<style>
  /* Move all styles to the top of the file */
  #location-access-prompt {
    display: none; /* Initially hidden */
    width: 300px;
    margin: 0 auto;
    text-align: center;
    padding: 20px;
    border: 2px solid #ccc;
    border-radius: 10px;
    background-color: #f9f9f9;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 1000;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  }

  #location-access-prompt h3 {
    margin-bottom: 15px;
    color: #333;
  }

  #location-access-prompt button {
    margin: 5px;
    padding: 8px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-weight: 500;
    transition: background-color 0.2s;
  }

  #grant-location-btn {
    background-color: #4CAF50;
    color: white;
  }

  #grant-location-btn:hover {
    background-color: #45a049;
  }

  #deny-location-btn {
    background-color: #f44336;
    color: white;
  }

  #deny-location-btn:hover {
    background-color: #da190b;
  }

  /* Login Section Styling */
  #login-section {
    width: 90%;
    max-width: 400px;
    margin: 2rem auto;
    padding: 2rem;
    background-color: var(--card-background);
    border-radius: 1rem;
    box-shadow: var(--shadow-lg);
    border: 1px solid var(--border-color);
  }

  #login-section form {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  #login-section label {
    font-weight: 500;
    color: var(--text-primary);
    margin-bottom: 0.25rem;
  }

  #login-section input {
    width: 100%;
    padding: 0.75rem 1rem;
    border: 1px solid var(--border-color);
    border-radius: 0.5rem;
    font-size: 1rem;
    transition: all 0.3s ease;
  }

  #login-section input:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
  }

  #login-section button {
    width: 100%;
    padding: 0.75rem 1.5rem;
    background-color: var(--primary-color);
    color: white;
    border: none;
    border-radius: 0.5rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  #login-section button:hover {
    background-color: var(--primary-hover);
    transform: translateY(-1px);
  }

  /* Loading States */
  .loading {
    position: relative;
    pointer-events: none;
    opacity: 0.7;
  }

  .loading::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 24px;
    height: 24px;
    margin: -12px 0 0 -12px;
    border: 2px solid var(--primary-color);
    border-top-color: transparent;
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  /* Error Messages */
  .error-message {
    display: none !important;
  }

  /* Success Messages */
  .success-message {
    display: none !important;
  }

  /* Map Controls */
  .map-controls {
    position: absolute;
    top: 1rem;
    right: 1rem;
    z-index: 1000;
    background: white;
    padding: 0.5rem;
    border-radius: 0.5rem;
    box-shadow: var(--shadow-md);
  }

  .map-controls button {
    display: block;
    width: 100%;
    margin: 0.25rem 0;
    padding: 0.5rem;
    border: none;
    border-radius: 0.25rem;
    background: var(--primary-color);
    color: white;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .map-controls button:hover {
    background: var(--primary-hover);
  }

  /* Place Info Box Styling */
  #place-info-box {
    position: fixed;
    bottom: 2rem;
    right: 2rem;
    width: 90%;
    max-width: 400px;
    background: white;
    border-radius: 1rem;
    box-shadow: var(--shadow-lg);
    padding: 1.5rem;
    z-index: 1000;
    transform: translateY(0);
    transition: transform 0.3s ease;
    display: none;
  }

  #place-info-box.visible {
    display: block;
    animation: slideUp 0.3s ease forwards;
  }

  #place-info-box.hidden {
    animation: slideDown 0.3s ease forwards;
  }

  @keyframes slideUp {
    from {
      transform: translateY(100%);
      opacity: 0;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  }

  @keyframes slideDown {
    from {
      transform: translateY(0);
      opacity: 1;
    }
    to {
      transform: translateY(100%);
      opacity: 0;
    }
  }

  #place-info-box h4 {
    color: var(--text-primary);
    font-size: 1.25rem;
    margin-bottom: 1rem;
    padding-bottom: 0.5rem;
    border-bottom: 2px solid var(--border-color);
  }

  #place-info-box p {
    margin: 0.5rem 0;
    color: var(--text-secondary);
  }

  #place-info-box strong {
    color: var(--text-primary);
  }

  .close-info {
    position: absolute;
    top: 1rem;
    right: 1rem;
    background: none;
    border: none;
    color: var(--text-secondary);
    cursor: pointer;
    padding: 0.25rem;
    font-size: 1.25rem;
    line-height: 1;
    transition: color 0.3s ease;
  }

  .close-info:hover {
    color: var(--text-primary);
  }

  /* Hide system messages */
  .error-message,
  .success-message {
    display: none !important;
  }

  /* General input and button styling */
  input, button {
    margin-top: 10px;
    padding: 10px 15px;
    border-radius: 5px;
    border: 1px solid #ccc;
    width: 80%;
    box-sizing: border-box;
  }

  button {
    cursor: pointer;
    background-color: #4CAF50;
    color: white;
    font-weight: bold;
  }

  button:hover {
    background-color: #45a049;
  }

  {% comment %} /* Map box styling */
  .map-box {
    height: 780px;
    width: 100%;
    margin: 40px auto;
    border: 2px solid #ccc;
    border-radius: 12px;
  } {% endcomment %}
  /* Styling for the map container */
.map-box {
  width: 100%;                 
  max-width: 1900px;        
  height: 80vh;               
  margin: 2rem auto;        
  
  border: 2px solid #3b82f6;  /* Blue border */
  border-radius: 12px;        /* Rounded corners */
  box-sizing: border-box;
  overflow: hidden;
  
  background: #f0f4ff;        /* Solid light blue background for a clean look */
  box-shadow: 0 4px 16px rgba(59, 130, 246, 0.2); /* Soft shadow */

  transition: box-shadow 0.3s ease, transform 0.3s ease;
  animation: mapFadeIn 0.7s ease;
}

/* Hover effect to give a subtle "lift" feeling */
.map-box:hover {
  box-shadow: 0 8px 24px rgba(59, 130, 246, 0.3);
  transform: translateY(-4px); /* Move up slightly */
}

/* Fade-in animation for a smooth appearance */
@keyframes mapFadeIn {
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

  
  /* Info box styling */
  .info-box {
    border: 1px solid #ccc;
    padding: 15px;
    margin-top: 20px;
    border-radius: 10px;
    max-width: 90%;
    margin-left: auto;
    margin-right: auto;
    background-color: #f9f9f9;
  }

  /* Form layout for manual location section */
  #manual-location-section {
    text-align: center;
    padding: 20px;
    background-color: #f9f9f9;
    border-radius: 10px;
  }
  /* Chart section */
  #chart-wrapper {
    display: none;
    text-align: center;
    width: 100%;
    max-width: 1200px;
    margin: 2rem auto;
    padding: 2rem;
    background: white;
    border-radius: 0.75rem;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
    transition: box-shadow 0.3s ease, transform 0.3s ease;
  }

  #chart-wrapper:hover {
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
    transform: translateY(-4px);
  }

  #chart-wrapper h3 {
    font-size: 1.75rem;
    color: #2563eb;
    margin-bottom: 1.5rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  #bar-chart {
    width: 100% !important;
    height: 400px !important;
    margin: 1rem auto;
  }

  @media (max-width: 768px) {
    #chart-wrapper {
      padding: 1rem;
      margin: 1rem;
    }
    
    #bar-chart {
      height: 300px !important;
    }
    
    #chart-wrapper h3 {
      font-size: 1.25rem;
    }
  } 
  {% comment %} /* Chart section */
  #chart-wrapper {
    display: none;
    width: 100%;
    max-width: 1200px;
    margin: 2rem auto;
    padding: 2rem;
    text-align: center;
    background: linear-gradient(135deg, #ffffff, #f9fafb); /* subtle gradient */
    border-radius: 1rem;
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.08);
    border: 1px solid #e5e7eb;
    position: relative;
    overflow: hidden;
    transition: box-shadow 0.3s ease, transform 0.3s ease;
  }
  
  #chart-wrapper::before {
    content: "";
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    border-radius: inherit;
    border: 2px solid transparent;
    background: linear-gradient(45deg, #3b82f6, #9333ea) border-box;
    -webkit-mask:
      linear-gradient(#fff 0 0) padding-box,
      linear-gradient(#fff 0 0);
    -webkit-mask-composite: destination-out;
    mask-composite: exclude;
    opacity: 0;
    transition: opacity 0.3s ease;
  }
  
  #chart-wrapper:hover::before {
    opacity: 1;
  }
  
  #chart-wrapper:hover {
    box-shadow: 0 12px 28px rgba(0, 0, 0, 0.12);
    transform: translateY(-4px);
  }
  
  #chart-wrapper h3 {
    font-size: 1.8rem;
    color: #3b82f6;
    margin-bottom: 1.5rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.08em;
  }
  
  #bar-chart {
    width: 100% !important;
    height: 400px !important;
    margin: 1rem auto;
  }
  
  /* Responsive adjustments */
  @media (max-width: 768px) {
    #chart-wrapper {
      padding: 1rem;
      margin: 1rem;
    }
  
    #chart-wrapper h3 {
      font-size: 1.4rem;
    }
  
    #bar-chart {
      height: 280px !important;
    }
  }
  
   {% endcomment %}

  #place-info-box {
    display: none;
    text-align: center;
  }

  @keyframes highlight {
    0% { box-shadow: 0 0 0px rgba(255, 0, 0, 0.7); }
    50% { box-shadow: 0 0 20px rgba(255, 0, 0, 0.7); }
    100% { box-shadow: 0 0 0px rgba(255, 0, 0, 0.7); }
  }
  
  .chart-highlight {
    animation: highlight 1.5s ease-in-out;
  }
  
  /* Related Places Styling */
  #related-places {
    margin-top: 1.5rem;
    padding-top: 1rem;
    border-top: 1px solid var(--border-color);
  }

  #related-places h5 {
    color: var(--text-primary);
    font-size: 1.1rem;
    margin-bottom: 1rem;
  }

  .related-place-card {
    background: var(--card-background);
    border: 1px solid var(--border-color);
    border-radius: 0.5rem;
    padding: 1rem;
    margin-bottom: 1rem;
    transition: all 0.3s ease;
  }

  .related-place-card:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-md);
  }

  .related-place-card h6 {
    color: var(--text-primary);
    margin-bottom: 0.5rem;
    font-size: 1rem;
  }

  .related-place-card p {
    color: var(--text-secondary);
    font-size: 0.875rem;
    margin-bottom: 0.75rem;
  }

  .related-place-card .badge {
    font-size: 0.75rem;
    padding: 0.35rem 0.65rem;
  }

  .spinner-border {
    width: 1.5rem;
    height: 1.5rem;
    margin: 1rem auto;
  }

  .alert {
    padding: 0.75rem 1rem;
    border-radius: 0.5rem;
    margin-bottom: 1rem;
    font-size: 0.875rem;
  }

  .alert-info {
    background-color: #e3f2fd;
    border-color: #bbdefb;
    color: #0d47a1;
  }

  .alert-danger {
    background-color: #ffebee;
    border-color: #ffcdd2;
    color: #b71c1c;
  }
</style>

<div id="main-map-container">
  {% if not user.is_authenticated %}
    <div id="login-section">
      <form method="POST" action="{% url 'login' %}">
        {% csrf_token %}
        <label for="email">Email:</label><br>
        <input type="email" name="email" required><br>
        <label for="password">Password:</label><br>
        <input type="password" name="password" required><br>
        <button type="submit">Login</button>
      </form>
    </div>
    <div id="city-search-bar" style="display:none; position: absolute; top: 64px; right: 0; z-index: 1200; align-items: center; min-width: 160px; max-width: 220px; background: #fff; border-radius: 2rem; box-shadow: 0 2px 8px rgba(0,0,0,0.13); padding: 0.1rem 0.7rem;">
      <span style="color: #65676b; font-size: 1rem; margin-right: 0.4rem; display: flex; align-items: center;">
        <i class="fa fa-search"></i>
      </span>
      <input id="location-input" type="text" placeholder="Search..." style="flex:1; border:none; outline:none; background: transparent; font-size: 0.95rem; color: #22223b; padding: 0.4rem 0; min-width: 50px;" />
      <button id="search-button" type="button" style="background: #2563eb; color: #fff; border: none; border-radius: 2rem; padding: 0.4rem 1rem; font-weight: 500; font-size: 0.95rem; margin-left: 0.4rem; cursor: pointer; transition: background 0.2s;">Search</button>
    </div>
    <div id="location-access-prompt">
      <h3>Allow location access?</h3>
      <button id="grant-location-btn">Yes</button>
      <button id="deny-location-btn">No</button>
    </div>

    <div id="manual-location-section" style="display:none;">
      <h3>Enter Your Location Manually:</h3>
      <p style="color: #666; font-size: 14px; margin-bottom: 10px;">
        <strong>Note:</strong> Only locations within Kathmandu, Lalitpur, or Bhaktapur districts are supported.
      </p>
      <input type="text" id="manual-location-input" placeholder="e.g., Kathmandu, Nepal" />
      <button id="submit-manual-location">Submit</button>
    </div>

    <div id="map-wrapper" style="display:none;">
      <div id="map" class="map-box"></div>
    </div>
    <div id="distances">
    <!-- Distances will be dynamically added here by JavaScript -->
    </div>
    
    <div id="chart-wrapper" style="display:none;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
        <h3 id="chart-title">Popular Places in Selected District</h3>
      </div>
      <canvas id="bar-chart" width="600" height="300"></canvas>
      <div id="chart-note" style="margin-top: 10px; font-size: 14px; color: #666; text-align: center;"></div>
    </div>

    <div id="place-info-box" style="display:none;" class="info-box">
      <h4 id="place-title"></h4>
      <p id="place-description"></p>
      <p><strong>Popular For:</strong> <span id="place-popular"></span></p>
      <p><strong>Category:</strong> <span id="place-category"></span></p>
      <p><strong>Crowd Level:</strong> <span id="place-crowd"></span></p>
      <p><strong>Status:</strong> <span id="place-status"></span></p>
      <p><strong>Tags:</strong> <span id="place-tags"></span></p>
      <div id="related-places" class="mt-4">
        <h5>Related Places</h5>
        <div id="related-places-list"></div>
      </div>
    </div>
  {% else %}
    <div id="location-access-prompt">
      <h3>Allow location access?</h3>
      <button id="grant-location-btn">Yes</button>
      <button id="deny-location-btn">No</button>
    </div>

    <div id="manual-location-section" style="display:none;">
      <h3>Enter Your Location Manually:</h3>
      <p style="color: #666; font-size: 14px; margin-bottom: 10px;">
        <strong>Note:</strong> Only locations within Kathmandu, Lalitpur, or Bhaktapur districts are supported.
      </p>
      <input type="text" id="manual-location-input" placeholder="e.g., Kathmandu, Nepal" />
      <button id="submit-manual-location">Submit</button>
    </div>

    <div id="map-wrapper" style="display:none;">
      <div id="map" class="map-box"></div>
    </div>
    <div id="distances">
    <!-- Distances will be dynamically added here by JavaScript -->
    </div>
    
    <div id="chart-wrapper" style="display:none;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
        <h3 id="chart-title">Popular Places in Selected District</h3>
      </div>
      <canvas id="bar-chart" width="600" height="300"></canvas>
      <div id="chart-note" style="margin-top: 10px; font-size: 14px; color: #666; text-align: center;"></div>
    </div>

    <div id="place-info-box" style="display:none;" class="info-box">
      <h4 id="place-title"></h4>
      <p id="place-description"></p>
      <p><strong>Popular For:</strong> <span id="place-popular"></span></p>
      <p><strong>Category:</strong> <span id="place-category"></span></p>
      <p><strong>Crowd Level:</strong> <span id="place-crowd"></span></p>
      <p><strong>Status:</strong> <span id="place-status"></span></p>
      <p><strong>Tags:</strong> <span id="place-tags"></span></p>
      <div id="related-places" class="mt-4">
        <h5>Related Places</h5>
        <div id="related-places-list"></div>
      </div>
    </div>
  {% endif %}
</div>

<!-- Scripts -->
<script src="https://cdn.jsdelivr.net/npm/leaflet/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
  let map, userLatLng = null, userMarker, routePolyline = null;
  let routingControl = null;
  let routeClicks = [];
  let routeClickCount = 1;

  const redIcon = new L.Icon({
    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png',
    shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
    iconSize: [25, 41],
    iconAnchor: [12, 41],
    popupAnchor: [1, -34],
    shadowSize: [41, 41]
  });

  // Global variables for data management
  let currentDataMode = 'tourism'; // Always use tourism data
  let lastDistrict = null;
  let lastCategory = null;
  let lastTimeSlot = null;

  // Helper function to validate if location is within allowed districts
  function validateDistrictLocation(displayName) {
    const allowedDistricts = ['kathmandu', 'lalitpur', 'bhaktapur', 'patan'];
    const isInAllowedDistrict = allowedDistricts.some(district => 
      displayName.toLowerCase().includes(district)
    );
    
    if (!isInAllowedDistrict) {
      alert("Location must be within Kathmandu, Lalitpur, or Bhaktapur districts. Reloading page...");
      window.location.reload();
      return false;
    }
    return true;
  }

  // Utility functions
  function showLoading(element) {
    element.classList.add('loading');
  }

  function hideLoading(element) {
    element.classList.remove('loading');
  }

  function showError(message) {
    console.error(message);
  }

  function showSuccess(message) {
    console.log(message);
  }

  // Wait for DOM and styles to be fully loaded
  document.addEventListener('DOMContentLoaded', function() {
    // Initialize data source toggle - removed since we always use tourism model
    // handleDataSourceToggle();
    
    // Show the location prompt after a small delay to ensure styles are applied
    const locationPrompt = document.getElementById("location-access-prompt");
    if (locationPrompt) {
      setTimeout(() => {
        locationPrompt.style.display = "block";
      }, 100);
    }

    const grantBtn = document.getElementById("grant-location-btn");
    if (grantBtn) {
      grantBtn.addEventListener("click", () => {
        if (locationPrompt) locationPrompt.style.display = "none";
        initializeMap();
        getCurrentLocation();
        localStorage.setItem('location_decision', 'granted');
        window.dispatchEvent(new Event('userLocationSet'));
        if (typeof showNavbarSearchBarIfAllowed === 'function') {
          showNavbarSearchBarIfAllowed();
        }
      });
    }

    const denyBtn = document.getElementById("deny-location-btn");
    if (denyBtn) {
      denyBtn.addEventListener("click", () => {
        if (locationPrompt) locationPrompt.style.display = "none";
        const manualSection = document.getElementById("manual-location-section");
        if (manualSection) manualSection.style.display = "block";
        initializeMap();
        localStorage.setItem('location_decision', 'denied');
        window.dispatchEvent(new Event('userLocationSet'));
      });
    }

    const submitManualBtn = document.getElementById("submit-manual-location");
    if (submitManualBtn) {
      submitManualBtn.addEventListener("click", async () => {
        const locationInputElem = document.getElementById("manual-location-input");
        const locationInput = locationInputElem ? locationInputElem.value.trim() : '';
        if (!locationInput) {
          alert("Please enter a location.");
          return;
        }
        try {
          const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(locationInput)}`);
          const data = await response.json();
          if (data.length === 0) {
            alert("Location not found. Reloading page...");
            window.location.reload();
            return;
          }
          const result = data[0];
          const displayName = result.display_name.toLowerCase();
          
          // Check if location is in Nepal
          if (!displayName.includes("nepal")) {
            alert("Only locations within Nepal are supported. Reloading page...");
            window.location.reload();
            return;
          }
          
          // Check if location is within the allowed districts (Kathmandu, Lalitpur, Bhaktapur)
          if (!validateDistrictLocation(displayName)) {
            return;
          }
          
          const lat = parseFloat(result.lat);
          const lon = parseFloat(result.lon);
          userLatLng = [lat, lon];
          localStorage.setItem('user_lat', lat);
          localStorage.setItem('user_lng', lon);
          alert(`Location set to: ${result.display_name}`);
          showUserLocation(userLatLng, "Manual Location Set");
          const manualSection = document.getElementById("manual-location-section");
          if (manualSection) manualSection.style.display = "none";
          const citySearchBar = document.getElementById("city-search-bar");
          if (citySearchBar) citySearchBar.style.display = "flex";
          window.dispatchEvent(new Event('userLocationSet'));
        } catch (error) {
          console.error("Error validating location:", error);
          alert("Something went wrong. Reloading page...");
          window.location.reload();
        }
      });
    }

    const searchBtn = document.getElementById("search-button");
    if (searchBtn) {
      searchBtn.addEventListener("click", async () => {
        const inputElem = document.getElementById("location-input");
        const input = inputElem ? inputElem.value.trim() : '';
        if (!input || !userLatLng) {
          showError("Please set your location and enter a district name, place name, or #category.");
          return;
        }
        showLoading(searchBtn);
        try {
          if (input.startsWith("#")) {
            const category = input.slice(1);
            await fetchPlacesByCategory(category);
          } else {
            // First, try to search for places by name to see if it's a specific place
            const placeResponse = await fetch(`/api/search/?q=${encodeURIComponent(input)}`);
            const placeData = await placeResponse.json();
            
            if (placeData.places && placeData.places.length > 0) {
              // If we found places by name, check if it's an exact match for a district
              const inputLower = input.toLowerCase();
              const allowedDistricts = ['kathmandu', 'lalitpur', 'bhaktapur'];
              
              if (allowedDistricts.includes(inputLower)) {
                // It's a district search, show bar graph
                await fetchPlacesByDistrict(input);
              } else {
                // It's a place name search, redirect to place details
                const place = placeData.places[0];
                if (place.id) {
                  window.location.href = `/place-details/${place.id}/`;
                } else {
                  showError('No place ID found for that name.');
                }
              }
            } else {
              // No places found by name, try as district
              let districtResponse = await fetch(`/places-by-district/${input}/`);
              let districtData = await districtResponse.json();
              if (districtData.places && districtData.places.length > 0) {
                await fetchPlacesByDistrict(input);
              } else {
                showError('No places or districts found matching your search.');
              }
            }
          }
          showSuccess('Search completed successfully');
        } catch (error) {
          console.error('Search error:', error);
          showError('Failed to complete search. Please try again.');
        } finally {
          hideLoading(searchBtn);
        }
      });
    }

    const locationInputElem = document.getElementById("location-input");
    if (locationInputElem) {
      locationInputElem.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          const searchBtn = document.getElementById("search-button");
          if (searchBtn) searchBtn.click();
        }
      });
    }

    // Auto-search functionality for district_search parameter
    const urlParams = new URLSearchParams(window.location.search);
    const districtSearch = urlParams.get('district_search');
    
    if (districtSearch) {
      // Wait a bit for the page to fully load, then perform the search
      setTimeout(() => {
        console.log('Auto-searching for district:', districtSearch);
        
        // Set the search input value
        const locationInput = document.getElementById('location-input');
        if (locationInput) {
          locationInput.value = districtSearch;
        }
        
        // Perform the district search
        fetchPlacesByDistrict(districtSearch);
        
        // Show a message to the user
        if (typeof showSuccess === 'function') {
          showSuccess(`Showing places in ${districtSearch} district`);
        }
      }, 1000); // Wait 1 second for page to load
    }
  });

  // Initialize map with better error handling
  function initializeMap() {
    try {
      document.getElementById("map-wrapper").style.display = "block";
      map = L.map('map').setView([27.7, 85.3], 13);
      
      // Add different map layers
      const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
      });

      const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        attribution: '&copy; Esri'
      });

      const baseMaps = {
        "Street": osmLayer,
        "Satellite": satelliteLayer
      };

      L.control.layers(baseMaps).addTo(map);
      osmLayer.addTo(map);

      // Add zoom control
      L.control.zoom({
        position: 'bottomright'
      }).addTo(map);

      // Add scale control
      L.control.scale({
        imperial: false,
        position: 'bottomleft'
      }).addTo(map);

      showSuccess('Map initialized successfully');
    } catch (error) {
      console.error('Error initializing map:', error);
      showError('Failed to initialize map. Please refresh the page.');
    }
  }

  // Improved location handling
  function getCurrentLocation() {
    const locationPrompt = document.getElementById("location-access-prompt");
    showLoading(locationPrompt);

    navigator.geolocation.getCurrentPosition(
      pos => {
        hideLoading(locationPrompt);
        userLatLng = [pos.coords.latitude, pos.coords.longitude];
        localStorage.setItem('user_lat', pos.coords.latitude);
        localStorage.setItem('user_lng', pos.coords.longitude);
        showUserLocation(userLatLng, "You are here!");
        document.getElementById("city-search-bar").style.display = "flex";
        window.dispatchEvent(new Event('userLocationSet'));
      },
      error => {
        hideLoading(locationPrompt);
        console.error('Geolocation error:', error);
        document.getElementById("manual-location-section").style.display = "block";
      },
      {
        enableHighAccuracy: true,
        timeout: 5000,
        maximumAge: 0
      }
    );
  }

  function showUserLocation(coords, label) {
    userLatLng = coords;
    map.setView(coords, 13);

    if (userMarker) map.removeLayer(userMarker);

    userMarker = L.marker(coords, { icon: redIcon, draggable: true })
      .addTo(map)
      .bindPopup(label)
      .openPopup();

    userMarker.on('dragend', async function(e) {
      const newPos = e.target.getLatLng();
      userLatLng = [newPos.lat, newPos.lng];
      const locationName = await reverseGeocode(newPos.lat, newPos.lng);
      
      // Validate that the dragged location is within allowed districts
      if (!validateDistrictLocation(locationName)) {
        return;
      }
      
      userMarker.bindPopup(`<b>Current Location:</b><br>${locationName}`).openPopup();
      console.log("Updated user location:", locationName, userLatLng);
    });
  }

  async function geocode(location) {
    const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(location)}`);
    const data = await res.json();
    if (data.length > 0) {
      return [parseFloat(data[0].lat), parseFloat(data[0].lon)];
    }
    return null;
  }

  async function reverseGeocode(lat, lng) {
    try {
      const res = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}`);
      const data = await res.json();
      if (data.display_name) {
        return data.display_name;
      }
      return `${lat.toFixed(4)}, ${lng.toFixed(4)}`;
    } catch (error) {
      console.error('Reverse geocoding error:', error);
      return `${lat.toFixed(4)}, ${lng.toFixed(4)}`;
    }
  }

  function displayPlacesOnMap(places) {
    if (window.placeMarkers) {
      window.placeMarkers.forEach(marker => map.removeLayer(marker));
    }
    window.placeMarkers = [];

    places.forEach(place => {
      if (place.latitude && place.longitude) {
        const marker = L.marker([place.latitude, place.longitude]).addTo(map)
          .bindPopup(`<b>${place.name}</b><br>${place.description || "No description"}`);
        window.placeMarkers.push(marker);
        
        marker.on('click', () => {
          showPlaceInfo(place);
          
          // Clear any existing routing
          if (routingControl) {
            map.removeControl(routingControl);
            routingControl = null;
          }
          if (window.activeRouteLine) {
            map.removeLayer(window.activeRouteLine);
            window.activeRouteLine = null;
          }
          
          // Clear any existing route click markers
          routeClicks.forEach(m => map.removeLayer(m));
          routeClicks = [];
          routeClickCount = 1;
          
          // Only create route if user location is available
          if (userLatLng) {
            console.log('Creating route from user location to:', place.name);
            console.log('User location:', userLatLng);
            console.log('Place location:', [place.latitude, place.longitude]);
            
            const userLocation = L.latLng(userLatLng[0], userLatLng[1]);
            const placeLocation = L.latLng(place.latitude, place.longitude);
            
            routingControl = L.Routing.control({
              waypoints: [userLocation, placeLocation],
              draggableWaypoints: true,
              routeWhileDragging: false,
              createMarker: function(i, wp) {
                if (i === 0) {
                  // User location marker (red) - preserve existing marker
                  if (userMarker && map.hasLayer(userMarker)) {
                    // Update existing marker position if needed
                    userMarker.setLatLng(wp.latLng);
                    return userMarker;
                  } else {
                    // Create new user marker only if it doesn't exist
                    userMarker = L.marker(wp.latLng, {
                      icon: redIcon,
                      draggable: true
                    }).bindPopup("Your Location").addTo(map);
                    
                    userMarker.on('dragend', async function(e) {
                      const newPos = e.target.getLatLng();
                      userLatLng = [newPos.lat, newPos.lng];
                      const locationName = await reverseGeocode(newPos.lat, newPos.lng);
                      
                      // Validate that the dragged location is within allowed districts
                      if (!validateDistrictLocation(locationName)) {
                        return;
                      }
                      
                      userMarker.bindPopup(`<b>Current Location:</b><br>${locationName}`).openPopup();
                      console.log("Updated user location:", locationName, userLatLng);
                    });
                    return userMarker;
                  }
                } else {
                  // Place marker (blue)
                  const blueIcon = new L.Icon({
                    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-blue.png',
                    shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
                    iconSize: [25, 41],
                    iconAnchor: [12, 41],
                    popupAnchor: [1, -34],
                    shadowSize: [41, 41]
                  });
                  return L.marker(wp.latLng, { icon: blueIcon }).bindPopup(place.name);
                }
              }
            }).addTo(map);
            
            // Handle route found event
            routingControl.on('routesfound', function(e) {
              console.log('Route found:', e);
              if (window.activeRouteLine) {
                map.removeLayer(window.activeRouteLine);
              }
              if (e.routes && e.routes.length > 0) {
                window.activeRouteLine = L.polyline(e.routes[0].coordinates, { 
                  color: 'blue',
                  weight: 5,
                  opacity: 0.7
                }).addTo(map);
                
                // Show route information
                const route = e.routes[0];
                const distance = (route.summary.totalDistance / 1000).toFixed(2); // Convert to km
                const duration = Math.round(route.summary.totalTime / 60); // Convert to minutes
                
                console.log(`Route to ${place.name}: ${distance} km, ${duration} minutes`);
                
                // Update place info with route details
                const placeInfo = document.getElementById('place-info-box');
                if (placeInfo) {
                  const routeInfo = document.createElement('div');
                  routeInfo.innerHTML = `
                    <div style="background: #e3f2fd; padding: 10px; border-radius: 5px; margin-top: 10px;">
                      <strong>Route Information:</strong><br>
                      Distance: ${distance} km<br>
                      Estimated Time: ${duration} minutes
                    </div>
                  `;
                  placeInfo.appendChild(routeInfo);
                }
              }
            });
            
            // Handle routing errors
            routingControl.on('routingerror', function(e) {
              console.error('Routing error:', e);
              alert('Unable to calculate route. Please check your location and try again.');
            });
            
          } else {
            console.log('No user location available for routing');
            alert('Please allow location access or set your location manually to see routes.');
          }
        });
      } else {
        console.warn('Place missing coordinates:', place);
      }
    });

    // Fit map to show all markers
    const validPlaces = places.filter(p => p.latitude && p.longitude);
    if (validPlaces.length > 0) {
      const bounds = L.latLngBounds(validPlaces.map(p => [p.latitude, p.longitude]));
      if (userLatLng) {
        bounds.extend(userLatLng);
      }
      map.fitBounds(bounds, { padding: [50, 50] });
    }
  }
  
  function renderBarChart(places) {
    console.log('Raw Places Data:', places);
  
    // Sort by crowdlevel descending
    places.sort((a, b) => b.crowdlevel - a.crowdlevel);
  
    let selectedPlaces = [];
    const totalPlaces = places.length;
    
    // Show all places (no artificial filtering)
    selectedPlaces = places;
    
    console.log('Filtered Selected Places:', selectedPlaces);
    console.log('Total places available:', totalPlaces, 'Displayed:', selectedPlaces.length);
    
    // Log the distribution for debugging
    const regularHighCount = selectedPlaces.filter(p => p.crowdlevel > 70).length;
    const regularMediumCount = selectedPlaces.filter(p => p.crowdlevel >= 30 && p.crowdlevel <= 70).length;
    const regularLowCount = selectedPlaces.filter(p => p.crowdlevel < 30).length;
    console.log('Final distribution:', { high: regularHighCount, medium: regularMediumCount, low: regularLowCount });
  
    const ctx = document.getElementById('bar-chart').getContext('2d');
  
    if (window.barChart) {
      window.barChart.destroy();
    }
  
    const chartData = selectedPlaces.map(place => place.crowdlevel);
    // Show only place names without status
    const labels = selectedPlaces.map(place => place.name);
  
    // Enhanced color scheme with better contrast
    const getColor = (crowdLevel) => {
      if (crowdLevel > 70) return '#DC2626'; // High crowd - Bright Red
      else if (crowdLevel >= 30) return '#F59E0B'; // Medium crowd - Amber/Orange
      else return '#059669'; // Low crowd - Emerald Green
    };
  
    const backgroundColors = selectedPlaces.map(place => getColor(place.crowdlevel));
  
    window.selectedPlaces = selectedPlaces; // Store the places data globally
    console.log('Stored in window.selectedPlaces:', window.selectedPlaces);
  
    // Update chart title with context info and count
    const chartTitle = document.getElementById('chart-title');
    if (chartTitle && selectedPlaces.length > 0) {
      const firstPlace = selectedPlaces[0];
      let title = 'Crowd Levels';
      if (firstPlace.time_slot) {
        title += ` (${firstPlace.time_slot.charAt(0).toUpperCase() + firstPlace.time_slot.slice(1)})`;
      }
      if (firstPlace.weather) {
        title += ` - ${firstPlace.weather}`;
      }
      
      // Add count information
      if (totalPlaces > selectedPlaces.length) {
        title += ` - Showing ${selectedPlaces.length} of ${totalPlaces} places`;
      } else {
        title += ` - ${totalPlaces} places`;
      }
      
      chartTitle.textContent = title;
    }
    
    // Add legend and note
    const chartNote = document.getElementById('chart-note');
    if (chartNote) {
        const regularHighCount = selectedPlaces.filter(p => p.crowdlevel > 70).length;
        const regularMediumCount = selectedPlaces.filter(p => p.crowdlevel >= 30 && p.crowdlevel <= 70).length;
        const regularLowCount = selectedPlaces.filter(p => p.crowdlevel < 30).length;
        
        chartNote.innerHTML = `
            <div style="display: flex; justify-content: center; gap: 20px; margin-bottom: 10px; flex-wrap: wrap;">
                <span style="display: flex; align-items: center; gap: 5px;">
                    <div style="width: 12px; height: 12px; background-color: #DC2626; border-radius: 2px;"></div>
                    <span>High Crowd (>70%): ${regularHighCount}</span>
                </span>
                <span style="display: flex; align-items: center; gap: 5px;">
                    <div style="width: 12px; height: 12px; background-color: #F59E0B; border-radius: 2px;"></div>
                    <span>Medium Crowd (30-70%): ${regularMediumCount}</span>
                </span>
                <span style="display: flex; align-items: center; gap: 5px;">
                    <div style="width: 12px; height: 12px; background-color: #059669; border-radius: 2px;"></div>
                    <span>Low Crowd (<30%): ${regularLowCount}</span>
                </span>
            </div>
            <div style="text-align: center; color: #666; font-size: 14px;">
                <i class="bi bi-info-circle"></i> Click on bars to view place details.
            </div>
        `;
    }
    
    // Create the chart
    window.barChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Crowd Level',
                data: selectedPlaces.map(p => p.crowdlevel),
                backgroundColor: backgroundColors,
                borderColor: '#4285F4',
                borderWidth: 1
            }]
        },
        options: {
            onClick: function (evt, activeEls, chart) {
                const elements = chart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, false);
                if (elements.length > 0) {
                    const index = elements[0].index;
                    const selectedPlace = window.selectedPlaces[index];
                    console.log('Bar clicked:', selectedPlace); // Debug log
                    if (selectedPlace && selectedPlace.id) {
                        goToPlaceDetails(selectedPlace);
                    } else {
                        console.warn('Selected place missing id:', selectedPlace);
                    }
                }
            },
            responsive: true,
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            // Only show crowd level with two decimals
                            return `Crowd Level: ${context.parsed.y.toFixed(2)}%`;
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    max: 100,
                    title: { display: true, text: 'Crowd Level (%)' }
                },
                x: {
                    title: { display: true, text: 'Places' }
                }
            }
        }
    });
    
    return selectedPlaces;
  }

  // Function to get current season
  function getCurrentSeason() {
    const month = new Date().getMonth() + 1; // getMonth() returns 0-11
    
    if (month >= 3 && month <= 5) {
      return 'Spring';
    } else if (month >= 6 && month <= 8) {
      return 'Summer';
    } else if (month >= 9 && month <= 11) {
      return 'Autumn';
    } else {
      return 'Winter';
    }
  }

// Utility: Map hour to time slot
function getTimeSlotFromHour(hour) {
  if (hour >= 5 && hour < 12) return 'morning';
  if (hour >= 12 && hour < 17) return 'afternoon';
  if (hour >= 17 && hour < 21) return 'evening';
  return 'morning'; // default fallback
}

// Function to handle data source toggle
function handleDataSourceToggle() {
  const toggle = document.getElementById('data-source-toggle');
  if (toggle) {
    toggle.addEventListener('change', async function() {
      currentDataMode = this.value;
      console.log('Data source changed to:', currentDataMode);
      
      // Refresh the current data with the new source
      if (lastDistrict) {
        await fetchPlacesByDistrict(lastDistrict);
      } else if (lastCategory) {
        await fetchPlacesByCategory(lastCategory);
      }
    });
  }
}

// Modified function to fetch places by district with data source support
async function fetchPlacesByDistrict(district) {
  lastDistrict = district;
  lastCategory = null;
  
  // Always use tourism model
  await fetchPlacesByDistrictTourism(district);
}

// Modified function to fetch places by category with data source support
async function fetchPlacesByCategory(category) {
  lastCategory = category;
  lastDistrict = null;
  
  // Always use tourism model
  await fetchPlacesByCategoryTourism(category);
}

// Function to clear all map data, routes, and place info
function clearMapData() {
  console.log('Clearing all map data...');
  
  // Clear routing
  if (routingControl) {
    map.removeControl(routingControl);
    routingControl = null;
  }
  if (window.activeRouteLine) {
    map.removeLayer(window.activeRouteLine);
    window.activeRouteLine = null;
  }
  
  // Clear route click markers
  routeClicks.forEach(m => map.removeLayer(m));
  routeClicks = [];
  routeClickCount = 1;
  
  // Clear only place markers (preserve user marker)
  if (window.placeMarkers) {
    window.placeMarkers.forEach(marker => {
      // Only remove if it's not the user marker
      if (marker !== userMarker) {
        map.removeLayer(marker);
      }
    });
    window.placeMarkers = [];
  }
  
  // Clear place info box
  const infoBox = document.getElementById("place-info-box");
  if (infoBox) {
    infoBox.classList.remove('visible');
    infoBox.classList.add('hidden');
    setTimeout(() => {
      infoBox.classList.remove('hidden');
    }, 300);
  }
  
  // Clear chart
  if (window.barChart) {
    window.barChart.destroy();
    window.barChart = null;
  }
  
  // Hide chart wrapper
  const chartWrapper = document.getElementById("chart-wrapper");
  if (chartWrapper) {
    chartWrapper.style.display = "none";
  }
  
  // Ensure user marker is still visible
  if (userLatLng && userMarker) {
    if (!map.hasLayer(userMarker)) {
      console.log('Re-adding user location marker...');
      map.addLayer(userMarker);
    }
  }
  
  console.log('Map data cleared successfully (user location preserved)');
}

// Function to show loading indicator
function showLoadingIndicator() {
  const chartWrapper = document.getElementById("chart-wrapper");
  if (chartWrapper) {
    // Create loading overlay
    const loadingOverlay = document.createElement('div');
    loadingOverlay.id = 'loading-overlay';
    loadingOverlay.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255,255,255,0.9);
      z-index: 10;
      display: flex;
      justify-content: center;
      align-items: center;
    `;
    loadingOverlay.innerHTML = `
      <div style="text-align: center;">
        <div style="width: 40px; height: 40px; border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 10px;"></div>
        <p id="loading-text" style="color: #666; margin: 0;">Loading places...</p>
        <p style="color: #999; margin: 5px 0 0 0; font-size: 12px;">This may take a few seconds for the first search</p>
      </div>
    `;
    
    // Make chart wrapper relative positioned if not already
    chartWrapper.style.position = 'relative';
    
    // Add loading overlay
    chartWrapper.appendChild(loadingOverlay);
    chartWrapper.style.display = "block";
  }
}

// Function to hide loading indicator
function hideLoadingIndicator() {
  const loadingOverlay = document.getElementById('loading-overlay');
  if (loadingOverlay) {
    loadingOverlay.remove();
  }
}

// Function to update loading text
function updateLoadingText(text) {
  const loadingText = document.getElementById('loading-text');
  if (loadingText) {
    loadingText.textContent = text;
  }
}

// Original tourism functions (renamed)
async function fetchPlacesByDistrictTourism(district) {
  try {
    // Clear all existing map data first
    clearMapData();
    
    // Show loading indicator
    showLoadingIndicator();
    updateLoadingText('Fetching tourism data and weather information...');
    
    // Do NOT determine or pass time_slot here
    const tourismData = await fetchTourismCrowdData(district, null); // Only district
    if (!tourismData) {
      hideLoadingIndicator();
      return;
    }

    console.log("Tourism API Response Data:", tourismData);

    if (!tourismData.places || !tourismData.places.length) {
      hideLoadingIndicator();
      alert("No tourism data found for this district.");
      return;
    }

    // Verify each place has required data
    const validPlaces = tourismData.places.map(place => {
      console.log("Processing tourism place:", place);
      if (!place.id) {
        console.error("Place missing ID:", place);
      }
      return place;
    });

    document.getElementById("chart-wrapper").style.display = "block";
    const selectedPlaces = renderTourismBarChart(tourismData);
    console.log("Rendered tourism places:", selectedPlaces);
    
    const chartWrapper = document.getElementById("chart-wrapper");
    chartWrapper.scrollIntoView({ behavior: "smooth" });
    chartWrapper.classList.add("chart-highlight");
    setTimeout(() => chartWrapper.classList.remove("chart-highlight"), 1500);
    
    displayPlacesOnMap(selectedPlaces);
    
    // Show tourism model info
    if (tourismData.model_used) {
      console.log(`Using ${tourismData.model_used} model for tourism predictions`);
    }
    
    // Show tourist season info
    if (tourismData.context?.tourist_season) {
      console.log(`Current tourist season: ${tourismData.context.tourist_season}`);
    }
    
    hideLoadingIndicator();
  } catch (error) {
    hideLoadingIndicator();
    console.error("Error fetching tourism data by district:", error);
    alert("Error loading tourism data. Please try again.");
  }
}

// Original tourism category function (renamed)
async function fetchPlacesByCategoryTourism(category) {
  try {
    // Clear all existing map data first
    clearMapData();
    
    // Show loading indicator
    showLoadingIndicator();
    updateLoadingText('Fetching tourism data and weather information...');
    
    // Do NOT determine or pass time_slot here
    const tourismData = await fetchTourismCrowdData(null, category); // Only category
    if (!tourismData) {
      hideLoadingIndicator();
      return;
    }
    
    console.log("Tourism API Response Data:", tourismData);
    
    if (!tourismData.places || !tourismData.places.length) {
      hideLoadingIndicator();
      alert("No tourism data found in this category.");
      return;
    }
    document.getElementById("chart-wrapper").style.display = "block";
    const selectedPlaces = renderTourismBarChart(tourismData);
    const chartWrapper = document.getElementById("chart-wrapper");
    chartWrapper.scrollIntoView({ behavior: "smooth" });
    chartWrapper.classList.add("chart-highlight");
    setTimeout(() => chartWrapper.classList.remove("chart-highlight"), 1500);
    displayPlacesOnMap(selectedPlaces);
    
    // Show tourism model info
    if (tourismData.model_used) {
      console.log(`Using ${tourismData.model_used} model for tourism predictions`);
    }
    
    // Show tourist season info
    if (tourismData.context?.tourist_season) {
      console.log(`Current tourist season: ${tourismData.context.tourist_season}`);
    }
    
    hideLoadingIndicator();
  } catch (error) {
    hideLoadingIndicator();
    console.error("Error fetching tourism data by category:", error);
    alert("An error occurred while fetching tourism data. Please try again.");
  }
}

// Regular model functions
async function fetchPlacesByDistrictRegular(district) {
  try {
    // Clear all existing map data first
    clearMapData();
    
    // Show loading indicator
    showLoadingIndicator();
    
    const now = new Date();
    const hour = now.getHours();
    const time_slot = getTimeSlotFromHour(hour);
    console.log("Fetching regular data for district:", district, "time_slot:", time_slot, "hour:", hour);
    
    // Use the improved crowd predictions API
    const response = await fetch(`/api/improved-crowd-predictions/?district=${district}&time_slot=${time_slot}`);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = await response.json();
    console.log("Regular API Response Data:", data);

    if (!data.places || !data.places.length) {
      hideLoadingIndicator();
      alert("No places found for this district.");
      return;
    }

    // Verify each place has required data
    const validPlaces = data.places.map(place => {
      console.log("Processing regular place:", place);
      if (!place.id) {
        console.error("Place missing ID:", place);
      }
      return place;
    });

    document.getElementById("chart-wrapper").style.display = "block";
    const selectedPlaces = renderBarChart(validPlaces);
    console.log("Rendered regular places:", selectedPlaces);
    
    const chartWrapper = document.getElementById("chart-wrapper");
    chartWrapper.scrollIntoView({ behavior: "smooth" });
    chartWrapper.classList.add("chart-highlight");
    setTimeout(() => chartWrapper.classList.remove("chart-highlight"), 1500);
    
    displayPlacesOnMap(selectedPlaces);
    
    // Show model info
    if (data.model_used) {
      console.log(`Using ${data.model_used} model for predictions`);
    }
    
    hideLoadingIndicator();
  } catch (error) {
    hideLoadingIndicator();
    console.error("Error fetching regular data by district:", error);
    alert("Error loading places. Please try again.");
  }
}

async function fetchPlacesByCategoryRegular(category) {
  try {
    // Clear all existing map data first
    clearMapData();
    
    // Show loading indicator
    showLoadingIndicator();
    
    const now = new Date();
    const hour = now.getHours();
    const time_slot = getTimeSlotFromHour(hour);
    console.log("Fetching regular data for category:", category, "time_slot:", time_slot, "hour:", hour);
    
    // Use the improved crowd predictions API
    const response = await fetch(`/api/improved-crowd-predictions/?category=${category}&time_slot=${time_slot}`);
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    const data = await response.json();
    console.log("Regular API Response Data:", data);
    
    if (!data.places || !data.places.length) {
      hideLoadingIndicator();
      alert("No places found in this category.");
      return;
    }
    document.getElementById("chart-wrapper").style.display = "block";
    const selectedPlaces = renderBarChart(data.places);
    const chartWrapper = document.getElementById("chart-wrapper");
    chartWrapper.scrollIntoView({ behavior: "smooth" });
    chartWrapper.classList.add("chart-highlight");
    setTimeout(() => chartWrapper.classList.remove("chart-highlight"), 1500);
    displayPlacesOnMap(selectedPlaces);
    
    // Show model info
    if (data.model_used) {
      console.log(`Using ${data.model_used} model for predictions`);
    }
    
    hideLoadingIndicator();
  } catch (error) {
    hideLoadingIndicator();
    console.error("Error fetching regular data by category:", error);
    alert("An error occurred while fetching places. Please try again.");
  }
}

  function displayPlaceDetails(place) {
    const detailsContainer = document.getElementById('place-details');
    detailsContainer.innerHTML = `
      <h2>${place.name}</h2>
      <p>${place.description}</p>
      <p><strong>Popular For:</strong> ${place.popular_for}</p>
      <p><strong>Location:</strong> ${place.lat}, ${place.lng}</p>
      <p><strong>Crowd Level:</strong> ${place.crowdlevel}</p>
      <!-- Add other details as needed -->
    `;
    detailsContainer.style.display = 'block'; // Show the details
  } 
  
  function showPlaceInfo(place) {
    const infoBox = document.getElementById("place-info-box");
    
    // Clear any existing route information
    const existingRouteInfo = infoBox.querySelector('[style*="background: #e3f2fd"]');
    if (existingRouteInfo) {
      existingRouteInfo.remove();
    }
    
    // Add close button if not exists
    if (!document.querySelector('.close-info')) {
      const closeBtn = document.createElement('button');
      closeBtn.className = 'close-info';
      closeBtn.innerHTML = '';
      closeBtn.onclick = () => {
        infoBox.classList.add('hidden');
        setTimeout(() => {
          infoBox.classList.remove('visible');
          infoBox.classList.remove('hidden');
        }, 300);
      };
      infoBox.appendChild(closeBtn);
    }

    // Update content
    document.getElementById("place-title").textContent = place.name;
    document.getElementById("place-description").textContent = place.description || "No description available.";
    document.getElementById("place-popular").textContent = place.popularfor || "N/A";
    document.getElementById("place-category").textContent = place.category || "N/A";
    document.getElementById("place-crowd").textContent = `${place.crowdlevel || "N/A"}%`;
    document.getElementById("place-status").textContent = place.status || "N/A";
    document.getElementById("place-tags").textContent = place.tags?.join(', ') || "N/A";

    // Fetch and display related places based on tags
    if (place.tags && place.tags.length > 0) {
      const relatedPlacesList = document.getElementById("related-places-list");
      relatedPlacesList.innerHTML = '<div class="text-center"><div class="spinner-border text-primary" role="status"></div></div>';
      if (place.tags.length === 1) {
        fetchPlacesByTag(place.tags[0], 10);
      } else {
        const promises = place.tags.map(tag => fetchPlacesByTag(tag, 3));
        Promise.all(promises).then(() => {}).catch(error => {
          console.error('Error fetching related places:', error);
          relatedPlacesList.innerHTML = '<div class="alert alert-danger">Failed to load related places</div>';
        });
      }
    }

    // Show the info box with animation
    infoBox.classList.add('visible');

    // Always show the bar graph when a marker is clicked
    const chartWrapper = document.getElementById('chart-wrapper');
    chartWrapper.style.display = 'block';

    // Render the full-day bar graph for this place if available, otherwise keep the previous one
    if (place.crowd_pattern && Array.isArray(place.crowd_pattern) && place.crowd_pattern.length > 0) {
      // renderFullDayBarGraph(place); // REMOVE THIS LINE
      fetchHourlyMLPredictions(place); // ADD THIS LINE
    }
  }  

  function addToSearchHistory(district) {
    const historySection = document.getElementById("search-history-section");
    const list = document.getElementById("search-history-list");
    const item = document.createElement("li");
    item.textContent = district;
    list.appendChild(item);
    historySection.style.display = "block";
  }

  // Calculate distance between two points
  function calculateDistance(lat1, lon1, lat2, lon2) {
    const R = 6371; // Earth's radius in km
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = 
      Math.sin(dLat/2) * Math.sin(dLat/2) +
      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
      Math.sin(dLon/2) * Math.sin(dLon/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
  }

  async function fetchPlacesByTag(tag, limit) {
    try {
        const response = await fetch(`/places-by-tag/${tag}/`);
        if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
        }

        const data = await response.json();
        const relatedPlacesList = document.getElementById("related-places-list");

        if (!data.places || data.places.length === 0) {
            if (relatedPlacesList.innerHTML.includes('spinner-border')) {
                relatedPlacesList.innerHTML = '<div class="alert alert-info">No related places found</div>';
            }
            return;
        }

        // Limit the number of places to display
        const placesToShow = data.places.slice(0, limit);

        // Create HTML for the places
        const placesHTML = placesToShow.map(place => `
            <div class="related-place-card">
                <h6>${place.name}</h6>
                <p class="small text-muted">${place.description.substring(0, 100)}...</p>
                <div class="d-flex justify-content-between align-items-center">
                    <span class="badge bg-primary">${place.category}</span>
                    <span class="badge ${getCrowdLevelBadgeClass(place.crowdlevel)}">
                        ${place.crowdlevel}% Crowd
                    </span>
                </div>
            </div>
        `).join('');

        // Update the related places list
        if (relatedPlacesList.innerHTML.includes('spinner-border')) {
            relatedPlacesList.innerHTML = placesHTML;
        } else {
            relatedPlacesList.innerHTML += placesHTML;
        }

    } catch (error) {
        console.error(`Error fetching places for tag ${tag}:`, error);
        const relatedPlacesList = document.getElementById("related-places-list");
        if (relatedPlacesList.innerHTML.includes('spinner-border')) {
            relatedPlacesList.innerHTML = '<div class="alert alert-danger">Failed to load related places</div>';
        }
    }
  }

  function getCrowdLevelBadgeClass(crowdLevel) {
    if (crowdLevel > 70) return 'bg-danger';
    if (crowdLevel >= 30) return 'bg-warning';
    return 'bg-success';
  }

  // Add this function to fetch place by name and redirect
  async function fetchPlaceByName(placeName) {
    try {
      // Call the backend search API for place name
      const response = await fetch(`/api/search/?q=${encodeURIComponent(placeName)}`);
      const data = await response.json();
      if (data.places && data.places.length > 0) {
        // Redirect to placedetails of the first matching place
        const place = data.places[0];
        if (place.id) {
          window.location.href = `/place-details/${place.id}/`;
        } else {
          alert('No place ID found for that name.');
        }
      } else {
        alert('No place found with that name.');
      }
    } catch (error) {
      alert('Error searching for place.');
      console.error(error);
    }
  }

  // Add this function to fetch hourly ML predictions for a place and render as a bar chart
  async function fetchHourlyMLPredictions(place) {
    try {
      const response = await fetch(`/api/ml-hourly-predictions/?place_id=${place.id}`);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      if (!data.hourly_predictions || data.hourly_predictions.length === 0) {
        alert('No hourly ML predictions found for this place.');
        return;
      }
      // Render the hourly ML predictions as a bar chart
      const labels = data.hourly_predictions.map(item => `${item.hour}:00`);
      const values = data.hourly_predictions.map(item => item.crowdlevel);
      const ctx = document.getElementById('bar-chart').getContext('2d');
      if (window.barChart) window.barChart.destroy();
      window.barChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Crowd Level (ML Predicted)',
            data: values,
            backgroundColor: values.map(val => val > 70 ? '#FF0000' : val > 30 ? '#FFEB3B' : '#4CAF50')
          }]
        },
        options: {
          responsive: true,
          scales: {
            y: { beginAtZero: true, max: 100 }
          }
        }
      });
      document.getElementById('chart-wrapper').style.display = 'block';
    } catch (error) {
      alert('Failed to fetch hourly ML predictions.');
      console.error(error);
    }
  }

  // Function to fetch tourism-based crowd data for charts
  async function fetchTourismCrowdData(district = null, category = null, time_slot = null) {
    try {
        // Build query parameters
        const params = new URLSearchParams();
        if (district) params.append('district', district);
        if (category) params.append('category', category);
        // Only append time_slot if explicitly provided (not null)
        if (time_slot !== null && time_slot !== undefined) {
            params.append('time_slot', time_slot);
        }
        params.append('limit', '7'); // Show top 7 places (changed from 10 to 7)
        // Use the new tourism crowd data endpoint
        const response = await fetch(`/api/tourism-crowd-charts/?${params.toString()}`);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        console.log("Tourism API Response Data:", data);

        if (!data.places || !data.places.length) {
            alert("No tourism data found for the selected criteria.");
            return null;
        }

        // Add tourism context information
        data.places.forEach(place => {
            place.tourism_context = {
                model_used: data.model_used,
                tourist_season: data.context?.tourist_season,
                is_weekend: data.context?.is_weekend,
                season: data.context?.season
            };
        });

        return data;
    } catch (error) {
        console.error("Error fetching tourism crowd data:", error);
        alert("Failed to fetch tourism data. Please try again.");
        return null;
    }
  }

  // Function to render tourism-based bar chart
  function renderTourismBarChart(tourismData) {
    console.log('Tourism Data for Chart:', tourismData);
    
    const places = tourismData.places;
    const chartData = tourismData.chart_data;
    
    // Don't sort here - use the data as provided by the API
    // The API already sorts by crowd level and limits to the requested number
    
    let selectedPlaces = places;
    const totalPlaces = places.length;
    
    console.log('Tourism places from API:', selectedPlaces);
    console.log('Total tourism places available:', totalPlaces, 'Displayed:', selectedPlaces.length);
    
    // Log the distribution for debugging
    const tourismHighCount = selectedPlaces.filter(p => p.crowdlevel > 70).length;
    const tourismMediumCount = selectedPlaces.filter(p => p.crowdlevel >= 30 && p.crowdlevel <= 70).length;
    const tourismLowCount = selectedPlaces.filter(p => p.crowdlevel < 30).length;
    console.log('Tourism Final distribution:', { high: tourismHighCount, medium: tourismMediumCount, low: tourismLowCount });
    
    console.log('Tourism Filtered Selected Places:', selectedPlaces);
    
    const ctx = document.getElementById('bar-chart').getContext('2d');
    
    if (window.barChart) {
        window.barChart.destroy();
    }
    
    // Show only place names without status
    const labels = selectedPlaces.map(place => place.name);
    
    // Enhanced color scheme with better contrast
    const getTourismColor = (crowdLevel) => {
        if (crowdLevel > 70) return '#DC2626'; // High crowd - Bright Red
        else if (crowdLevel >= 30) return '#F59E0B'; // Medium crowd - Amber/Orange
        else return '#059669'; // Low crowd - Emerald Green
    };
    
    const backgroundColors = selectedPlaces.map(place => getTourismColor(place.crowdlevel));
    
    window.selectedPlaces = selectedPlaces; // Store the places data globally
    
    // Update chart title with tourism context
    const chartTitle = document.getElementById('chart-title');
    if (chartTitle && selectedPlaces.length > 0) {
        const firstPlace = selectedPlaces[0];
        let title = 'Crowd Levels';
        if (firstPlace.time_slot) {
            title += ` (${firstPlace.time_slot.charAt(0).toUpperCase() + firstPlace.time_slot.slice(1)})`;
        }
        
        // Add weather information if available
        if (firstPlace.weather_condition) {
            title += ` - ${firstPlace.weather_condition}`;
        }
        
        // Add current season information
        const currentSeason = getCurrentSeason();
        if (currentSeason) {
            title += ` - ${currentSeason} Season`;
        }
        
        // Add count information
        if (totalPlaces > selectedPlaces.length) {
            title += ` - Showing ${selectedPlaces.length} of ${totalPlaces} places`;
        } else {
            title += ` - ${totalPlaces} places`;
        }
        
        chartTitle.textContent = title;
    }
    
    // Add legend and weather impact note
    const chartNote = document.getElementById('chart-note');
    if (chartNote) {
        
        let weatherNote = '';
        // Add weather impact information if available
        if (selectedPlaces.length > 0 && selectedPlaces[0].weather_condition) {
            const weatherCondition = selectedPlaces[0].weather_condition;
            
            if (weatherCondition === 'Rainy') {
                weatherNote = ` <i class="bi bi-cloud-rain"></i> Rainy weather may reduce crowds.`;
            } else if (weatherCondition === 'Sunny') {
                weatherNote = ` <i class="bi bi-sun"></i> Sunny weather may increase crowds.`;
            } else if (weatherCondition === 'Foggy') {
                weatherNote = ` <i class="bi bi-cloud-fog"></i> Foggy weather may slightly reduce crowds.`;
            }
        }
        
        chartNote.innerHTML = `
            <div style="display: flex; justify-content: center; gap: 20px; margin-bottom: 10px; flex-wrap: wrap;">
                <span style="display: flex; align-items: center; gap: 5px;">
                    <div style="width: 12px; height: 12px; background-color: #DC2626; border-radius: 2px;"></div>
                    <span>High Crowd (>70%): ${tourismHighCount}</span>
                </span>
                <span style="display: flex; align-items: center; gap: 5px;">
                    <div style="width: 12px; height: 12px; background-color: #F59E0B; border-radius: 2px;"></div>
                    <span>Medium Crowd (30-70%): ${tourismMediumCount}</span>
                </span>
                <span style="display: flex; align-items: center; gap: 5px;">
                    <div style="width: 12px; height: 12px; background-color: #059669; border-radius: 2px;"></div>
                    <span>Low Crowd (<30%): ${tourismLowCount}</span>
                </span>
            </div>
            <div style="text-align: center; color: #666; font-size: 14px;">
                <i class="bi bi-info-circle"></i> Click on bars to view place details.${weatherNote}
            </div>
        `;
    }
    
    // Create the chart
    window.barChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Crowd Level',
                data: selectedPlaces.map(p => p.crowdlevel),
                backgroundColor: backgroundColors,
                borderColor: '#4285F4',
                borderWidth: 1
            }]
        },
        options: {
            onClick: function (evt, activeEls, chart) {
                const elements = chart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, false);
                if (elements.length > 0) {
                    const index = elements[0].index;
                    const selectedPlace = window.selectedPlaces[index];
                    console.log('Bar clicked:', selectedPlace); // Debug log
                    if (selectedPlace && selectedPlace.id) {
                        goToPlaceDetails(selectedPlace);
                    } else {
                        console.warn('Selected place missing id:', selectedPlace);
                    }
                }
            },
            responsive: true,
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            // Only show crowd level with two decimals
                            return `Crowd Level: ${context.parsed.y.toFixed(2)}%`;
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    max: 100,
                    title: { display: true, text: 'Crowd Level (%)' }
                },
                x: {
                    title: { display: true, text: 'Places' }
                }
            }
        }
    });
    
    return selectedPlaces;
  }

  // Find the function that handles bar clicks or place selection for details
  function goToPlaceDetails(place) {
    // Always use the place's own district and category for details
    const district = place.district || '';
    const category = place.category || '';
    // Do NOT include time_slot or weather_condition unless explicitly set by user
    const detailsUrl = `/place-details/${place.id}/?district=${encodeURIComponent(district)}&category=${encodeURIComponent(category)}`;
    console.log('[DEBUG] Navigating to:', detailsUrl);
    window.location.href = detailsUrl;
  }
</script>
{% endblock %}