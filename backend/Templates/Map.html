{% extends "base.html" %}
{% block title %}Map Tracker{% endblock %}

{% block content %}
{% if not user.is_authenticated %}
  <div id="login-section">
    <form method="POST" action="{% url 'login' %}">
      {% csrf_token %}
      <label for="username">Username:</label><br>
      <input type="text" name="username" required><br>
      <label for="password">Password:</label><br>
      <input type="password" name="password" required><br>
      <button type="submit">Login</button>
    </form>
  </div>
{% else %}
  <div id="location-access-prompt">
    <h3>Allow location access?</h3>
    <button id="grant-location-btn">Yes</button>
    <button id="deny-location-btn">No</button>
  </div>

  <div id="manual-location-section" style="display:none;">
    <h3>Enter Your Location Manually:</h3>
    <input type="text" id="manual-location-input" placeholder="e.g., Kathmandu, Nepal" />
    <button id="submit-manual-location">Submit</button>
  </div>

  <div id="city-search-section" style="display:none;">
    <h3>Explore here:</h3>
    <input id="location-input" type="text" placeholder="Enter district or #category" />
    <button id="search-button">Search</button>

  </div>

  <div id="map-wrapper" style="display:none;">
    <div id="map" class="map-box"></div>
  </div>
  <div id="distances">
  <!-- Distances will be dynamically added here by JavaScript -->
</div>
  
  <div id="chart-wrapper" style="display:none;">
    <h3>Popular Places in Selected District</h3>
    <canvas id="bar-chart" width="600" height="300"></canvas>
  </div>

  <div id="place-info-box" style="display:none;" class="info-box">
    <h4 id="place-title"></h4>
    <p id="place-description"></p>
    <p><strong>Popular For:</strong> <span id="place-popular"></span></p>
    <p><strong>Category:</strong> <span id="place-category"></span></p>
    <p><strong>Crowd Level:</strong> <span id="place-crowd"></span></p>
    <p><strong>Status:</strong> <span id="place-status"></span></p>
    <p><strong>Tags:</strong> <span id="place-tags"></span></p>
  </div>
{% endif %}

<!-- Scripts -->
<script src="https://cdn.jsdelivr.net/npm/leaflet/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<!-- Styles -->
<style>
  /* Center the location access prompt */
  #location-access-prompt {
    display: block;
    width: 300px;
    margin: 0 auto;
    text-align: center;
    padding: 20px;
    border: 2px solid #ccc;
    border-radius: 10px;
    background-color: #f9f9f9;
  }

  /* General input and button styling */
  input, button {
    margin-top: 10px;
    padding: 10px 15px;
    border-radius: 5px;
    border: 1px solid #ccc;
    width: 80%;
    box-sizing: border-box;
  }

  button {
    cursor: pointer;
    background-color: #4CAF50;
    color: white;
    font-weight: bold;
  }

  button:hover {
    background-color: #45a049;
  }

  /* Map box styling */
  .map-box {
    height: 600px;
    width: 90%;
    margin: 20px auto;
    border: 2px solid #ccc;
    border-radius: 12px;
  }

  /* Info box styling */
  .info-box {
    border: 1px solid #ccc;
    padding: 15px;
    margin-top: 20px;
    border-radius: 10px;
    max-width: 90%;
    margin-left: auto;
    margin-right: auto;
    background-color: #f9f9f9;
  }

  /* Form layout for manual location section */
  #manual-location-section {
    text-align: center;
    padding: 20px;
    background-color: #f9f9f9;
    border-radius: 10px;
  }

  /* Chart section */
  #chart-wrapper {
    display: none; /* change this from 'block' to 'none' */
    text-align: center;
  }
  

  #place-info-box {
    display: none;
    text-align: center;
  }
</style>

{% if user.is_authenticated %}
<script>
  let map, userLatLng = null, userMarker;

  const redIcon = new L.Icon({
    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png',
    shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
    iconSize: [25, 41],
    iconAnchor: [12, 41],
    popupAnchor: [1, -34],
    shadowSize: [41, 41]
  });


  window.onload = () => {
    document.getElementById("location-access-prompt").style.display = "block";

    document.getElementById("grant-location-btn").addEventListener("click", () => {
      document.getElementById("location-access-prompt").style.display = "none";
      initializeMap();
      getCurrentLocation();
    });

    document.getElementById("deny-location-btn").addEventListener("click", () => {
      document.getElementById("location-access-prompt").style.display = "none";
      document.getElementById("manual-location-section").style.display = "block";
      initializeMap();
    });

    document.getElementById("submit-manual-location").addEventListener("click", async () => {
      const location = document.getElementById("manual-location-input").value;
      const coords = await geocode(location);
      if (coords) {
        userLatLng = coords;
        showUserLocation(coords, "Manual Location Set");
        document.getElementById("manual-location-section").style.display = "none";
        document.getElementById("city-search-section").style.display = "block";
      }
    });

    document.getElementById("search-button").addEventListener("click", async () => {
      const input = document.getElementById("location-input").value.trim();
      if (!input || !userLatLng) return alert("Please set your location and enter a district name or #category.");
    
      if (input.startsWith("#")) {
        const category = input.slice(1);
        await fetchPlacesByCategory(category);
      } else {
        await fetchPlacesByDistrict(input);
      }
    });   
  }
  document.getElementById("submit-manual-location").addEventListener("click", async () => {
    const locationInput = document.getElementById("manual-location-input").value.trim();
  
    if (!locationInput) {
      alert("Please enter a location.");
      return;
    }
  
    try {
      const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(locationInput)}`);
      const data = await response.json();
  
      if (data.length === 0) {
        alert("Location not found. Reloading page...");
        window.location.reload(); // ðŸ‘ˆ reload if location not found
        return;
      }
  
      const result = data[0];
      const displayName = result.display_name.toLowerCase();
  
      if (!displayName.includes("nepal")) {
        alert("Only locations within Nepal are supported. Reloading page...");
        window.location.reload(); // ðŸ‘ˆ reload if location is outside Nepal
        return;
      }
  
      const lat = parseFloat(result.lat);
      const lon = parseFloat(result.lon);
      userLatLng = [lat, lon];
  
      alert(`Location set to: ${result.display_name}`);
      map.setView(userLatLng, 13);
  
    } catch (error) {
      console.error("Error validating location:", error);
      alert("Something went wrong. Reloading page...");
      window.location.reload(); // ðŸ‘ˆ reload on error
    }
  });
  

  function initializeMap() {
    document.getElementById("map-wrapper").style.display = "block";
    map = L.map('map').setView([27.7, 85.3], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);
  }
  function getCurrentLocation() {
    navigator.geolocation.getCurrentPosition(pos => {
      userLatLng = [pos.coords.latitude, pos.coords.longitude];
      showUserLocation(userLatLng, "You are here!");
      document.getElementById("city-search-section").style.display = "block";
    }, () => {
      alert("Location access denied.");
    });
  }
  

  function showUserLocation(coords, label) {
    map.setView(coords, 13);
    
    if (userMarker) map.removeLayer(userMarker);
  
    userMarker = L.marker(coords, { icon: redIcon, draggable: true }).addTo(map).bindPopup(label).openPopup();

  
    userMarker.on('dragend', function (e) {
      const newCoords = e.target.getLatLng();
      userLatLng = [newCoords.lat, newCoords.lng];
  
      // Show loading while fetching
      userMarker.bindPopup("Loading location name...").openPopup();
  
      // Reverse geocode using Nominatim
      fetch(`https://nominatim.openstreetmap.org/reverse?lat=${newCoords.lat}&lon=${newCoords.lng}&format=json`)
        .then(response => response.json())
        .then(data => {
          const locationName = data.display_name || "Unknown location";
          userMarker.bindPopup(locationName).openPopup();
        })
        .catch(err => {
          console.error("Reverse geocoding failed:", err);
          userMarker.bindPopup("Location name not found").openPopup();
        });
    });
  }
  
  async function geocode(location) {
    const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(location)}`);
    const data = await res.json();
    if (data.length > 0) {
      return [parseFloat(data[0].lat), parseFloat(data[0].lon)];
    }
    return null;
  }

  {% comment %} async function fetchPlacesByDistrict(district) {
    try {
      console.log("Fetching places for district:", district);
      const response = await fetch(`/places-by-district/${district}`);
      const data = await response.json();
      console.log("Fetched data:", data);

      if (!data.places || !data.places.length) {
        alert("No places found for this district.");
        return;
      }

      document.getElementById("chart-wrapper").style.display = "block";
      renderBarChart(data.places);
      displayPlacesOnMap(data.places);
    } catch (error) {
      console.error("Error fetching places by district:", error);
    }
  }
  async function fetchPlacesByCategory(category) {
    try {
      console.log("Fetching places for category:", category);
      const response = await fetch(`/places-by-category/${category}`);
      const data = await response.json();
      console.log("Fetched data for category:", data);
  
      if (!data.places || !data.places.length) {
        alert("No places found in this category.");
        return;
      }
  
      document.getElementById("chart-wrapper").style.display = "block";
      renderBarChart(data.places);
      displayPlacesOnMap(data.places);
    } catch (error) {
      console.error("Error fetching places by category:", error);
    }
  } {% endcomment %}

{% comment %} 
  async function fetchPlacesByCategory(category) {
    try {
      const encodedCategory = encodeURIComponent(category); // Encode the category
      console.log("Fetching places for category:", category);
  
      const response = await fetch(`/places-by-category/${encodedCategory}`);  // Use the encoded value in the URL
      const data = await response.json();
      console.log("Fetched data for category:", data);
  
      if (!data.places || !data.places.length) {
        alert("No places found in this category.");
        return;
      }
  
      // Example of displaying the category and place names on the UI
      const placesContainer = document.getElementById("places-container");
      placesContainer.innerHTML = "";  // Clear any previous results
  
      data.places.forEach(place => {
        const placeElement = document.createElement("div");
        placeElement.classList.add("place-item");
        placeElement.innerHTML = `
          <h3>${place.name}</h3>
          <p><strong>Category:</strong> ${place.category}</p>
          <p><strong>Description:</strong> ${place.description}</p>
          <p><strong>Crowd Level:</strong> ${place.crowdlevel}</p>
          <p><strong>Location:</strong> ${place.location}</p>
        `;
        placesContainer.appendChild(placeElement);
      });
  
      document.getElementById("chart-wrapper").style.display = "block";
      renderBarChart(data.places);
      displayPlacesOnMap(data.places);
    } catch (error) {
      console.error("Error fetching places by category:", error);
    }
  }
   {% endcomment %}
  function displayPlacesOnMap(places) {
    places.forEach(place => {
      if (place.latitude && place.longitude) {
        const marker = L.marker([place.latitude, place.longitude]).addTo(map);
        marker.bindPopup(`<strong>${place.name}</strong><br>${place.description}`).openPopup();
      }
    });
  }
  function renderBarChart(places) {
    console.log('Places Data:', places);
  
    // Sort by crowdlevel descending
    places.sort((a, b) => b.crowdlevel - a.crowdlevel);
  
    // Filter places by crowd level
    const highCrowd = places.filter(p => p.crowdlevel >= 75).slice(0, 3);
    const mediumCrowd = places.filter(p => p.crowdlevel >= 50 && p.crowdlevel < 75).slice(0, 2);
    const lowCrowd = places.filter(p => p.crowdlevel < 50).slice(0, 2);
  
    // Combine them
    const selectedPlaces = [...highCrowd, ...mediumCrowd, ...lowCrowd];
  
    const ctx = document.getElementById('bar-chart').getContext('2d');
  
    if (window.barChart) {
      window.barChart.destroy();
    }
  
    const chartData = selectedPlaces.map(place => place.crowdlevel);
    const labels = selectedPlaces.map(place => place.name);
  
    const getColor = (crowdLevel) => {
      if (crowdLevel >= 75) return '#FF0000'; // High crowd
      else if (crowdLevel >= 50) return '#FFEB3B'; // Medium crowd
      else return '#4CAF50'; // Low crowd
    };
  
    const backgroundColors = selectedPlaces.map(place => getColor(place.crowdlevel));
  
    window.barChart = new Chart(ctx, {
      type: 'bar',
      data: {
        labels: labels,
        datasets: [{
          label: 'Crowd Level',
          data: chartData,
          backgroundColor: backgroundColors,
          borderColor: '#388E3C',
          borderWidth: 1
        }]
      },
      options: {
        onClick: function (evt, activeEls, chart) {
          const elements = chart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, false);
          if (elements.length > 0) {
            const index = elements[0].index;
            const selectedPlace = selectedPlaces[index];
            if (selectedPlace && selectedPlace.id) {
              window.location.href = `/place-details/${selectedPlace.id}/`;
            }
          }
        },
        responsive: true,
        plugins: {
          legend: {
            display: false
          }
        }
      }
    });
  }
  
// Function to fetch places by district
// Function to fetch places by district
async function fetchPlacesByDistrict(district) {
  try {
    console.log("Fetching places for district:", district);
    const response = await fetch(`/places-by-district/${district}/`);
    const data = await response.json();
    console.log("Fetched data:", data);

    if (!data.places || !data.places.length) {
      alert("No places found for this district.");
      return;
    }

    // Display the chart and map wrapper
    document.getElementById("chart-wrapper").style.display = "block";
    
    // Render the bar chart with the fetched data
    renderBarChart(data.places);
    
    // Display places on the map
    displayPlacesOnMap(data.places);

  } catch (error) {
    console.error("Error fetching places by district:", error);
  }
} 
{% comment %} async function fetchPlacesByCategory(category){
  try{
    console response = await fetch('/places-by-category/${category}/');
    const data = await response.json();
    console.log("Fetched data:", data);

    if (!data.places || !data.places.length) {
      alert("No places found for this category.");
      return;
    }

    // Display the chart and map wrapper
    document.getElementById("chart-wrapper").style.display = "block";
    
    // Render the bar chart with the fetched data
    renderBarChart(data.places);
    
    // Display places on the map
    displayPlacesOnMap(data.places);

  } catch (error) {
    console.error("Error fetching places by district:", error);
  }
} 
 {% endcomment %}


{% comment %} 
async function fetchPlacesByDistrict(district) {
  try {
    console.log("Fetching places for category:", district);
    const response = await fetch(`/places-by-district/${district}/`);
    const data = await response.json();
    console.log("Fetched data for districtss:", data);

    if (!data.places || !data.places.length) {
      alert("No places found in this districtss.");
      return;
    }

    // Display the chart and map wrapper
    document.getElementById("chart-wrapper").style.display = "block";
    
    // Render the bar chart with the fetched data
    renderBarChart(data.places);
    
    // Display places on the map
    displayPlacesOnMap(data.places);

  } catch (error) {
    console.error("Error fetching places by category:", error);
  }
} {% endcomment %}

// Function to fetch places by category (hashtag)
async function fetchPlacesByCategory(category) {
  try {
    console.log("Fetching places for category:", category);
    const response = await fetch(`/places-by-category/${category}`);
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }

    const data = await response.json();

    console.log("Fetched data for category:", data);

    if (!data.places || !data.places.length) {
      alert("No places found in this category.");
      return;
    }

    // Display the chart and map wrapper
    document.getElementById("chart-wrapper").style.display = "block";
    
    // Render the bar chart with the fetched data
    renderBarChart(data.places);
    
    // Display places on the map
    displayPlacesOnMap(data.places);

  } catch (error) {
    console.error("Error fetching places by category:", error);
    alert("An error occurred while fetching places. Please try again.");
  }
}

// Function to display places on map
{% comment %} function displayPlacesOnMap(places) {
  clearMarkers(); // Clear existing Leaflet markers

  places.forEach(place => {
    if (place.lat && place.lng) {
      const marker = L.marker([place.lat, place.lng])
        .addTo(map)
        .bindPopup(`<b>${place.name}</b><br>${place.description || "No description"}`);
  
      marker.on('click', () => showPlaceInfo(place));
      mapMarkers.push(marker);
    }
  });
  

  // Center and zoom to the first valid place
  const firstPlace = places.find(p => p.latitude && p.longitude);
  if (firstPlace) {
    map.setView([firstPlace.latitude, firstPlace.longitude], 12);
  }
} {% endcomment %}
function showPlacesOnMap(places) {
  // Remove existing place markers or polylines if needed
  if (window.placeMarkers) {
    window.placeMarkers.forEach(marker => map.removeLayer(marker));
  }
  if (window.placePaths) {
    window.placePaths.forEach(path => map.removeLayer(path));
  }

  window.placeMarkers = [];
  window.placePaths = [];

  places.forEach(place => {
    const coords = [place.latitude, place.longitude]; // Ensure your API returns these

    // Create marker for each place
    const marker = L.marker(coords).addTo(map).bindPopup(place.name);
    window.placeMarkers.push(marker);

    // Draw line from user location to this place
    if (userLatLng) {
      const path = L.polyline([userLatLng, coords], {
        color: 'blue',
        weight: 2,
        dashArray: '4'
      }).addTo(map);
      window.placePaths.push(path);
    }
  });

  // Zoom out to fit all markers and user location
  const bounds = L.latLngBounds([
    ...places.map(p => [p.latitude, p.longitude]),
    userLatLng
  ]);
  map.fitBounds(bounds, { padding: [50, 50] });
}




{% comment %} function handleLocationSearch(location) {
    fetchNearbyPlaces(location).then(places => {
      renderBarChart(places);
    });
  }
   
 // Assuming you have an input field for the user to search for a location (like "Kathmandu")
    document.getElementById('search-button').addEventListener('click', () => {
    const location = document.getElementById('location-input').value; // Get the location from input
    handleLocationSearch(location); // Render the chart for that location
  });  {% endcomment %}


  // Function to display places and show the route from user location to the searched place
function displayPlacesOnMap(places) {
  places.forEach(place => {
    if (place.latitude && place.longitude) {
      const marker = L.marker([place.latitude, place.longitude]).addTo(map)
        .bindPopup(`<b>${place.name}</b><br>${place.description || "No description"}`);

      marker.on('click', () => {
        showPlaceInfo(place);

        // Fetch the user's current location
        if (userLatLng) {
          const userLocation = L.latLng(userLatLng[0], userLatLng[1]);
          const placeLocation = L.latLng(place.latitude, place.longitude);
          
          // Add the route from the user's current location to the clicked place
          L.Routing.control({
            waypoints: [userLocation, placeLocation],
            routeWhileDragging: true
          }).addTo(map);
        }
      });
    }
  });
}

  function displayPlaceDetails(place) {
    const detailsContainer = document.getElementById('place-details');
    detailsContainer.innerHTML = `
      <h2>${place.name}</h2>
      <p>${place.description}</p>
      <p><strong>Popular For:</strong> ${place.popular_for}</p>
      <p><strong>Location:</strong> ${place.lat}, ${place.lng}</p>
      <p><strong>Crowd Level:</strong> ${place.crowdlevel}</p>
      <!-- Add other details as needed -->
    `;
    detailsContainer.style.display = 'block'; // Show the details
  } 
  
  function showPlaceInfo(place) {
    const infoBox = document.getElementById("place-info-box");
    infoBox.style.display = "block";
    document.getElementById("place-title").textContent = place.name;
    document.getElementById("place-description").textContent = place.description || "No description available.";
    document.getElementById("place-popular").textContent = place.popularfor || "N/A";
    document.getElementById("place-category").textContent = place.category || "N/A";
    document.getElementById("place-crowd").textContent = place.crowdlevel || "N/A";
    document.getElementById("place-status").textContent = place.status || "N/A";
    document.getElementById("place-tags").textContent = place.tags?.join(', ') || "N/A";
  } 

  function addToSearchHistory(district) {
    const historySection = document.getElementById("search-history-section");
    const list = document.getElementById("search-history-list");
    const item = document.createElement("li");
    item.textContent = district;
    list.appendChild(item);
    historySection.style.display = "block";
  }
</script>
{% endif %}
{% endblock %}